(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{69:function(e,a,n){"use strict";n.r(a);var t=n(0),r=Object(t.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,a=e.$createElement,n=e._self._c||a;return n("div",{staticClass:"content"},[n("h2",{attrs:{id:"q-函数记忆是什么？什么场景下使用？（动态规划）"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#q-函数记忆是什么？什么场景下使用？（动态规划）","aria-hidden":"true"}},[e._v("#")]),e._v(" Q: 函数记忆是什么？什么场景下使用？（动态规划）")]),n("h2",{attrs:{id:"a："}},[n("a",{staticClass:"header-anchor",attrs:{href:"#a：","aria-hidden":"true"}},[e._v("#")]),e._v(" A：")]),n("p",[e._v("01，将上次计算结果保存起来的函数，称为有记忆能力（memorization）的函数。")]),n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('function memorize(f) {\n    var cache = {}; \n    return function() {\n         var key = arguments.length + Array.prototype.join.call(arguments,",");\n         if (key in cache) return cache[key];\n         else return cache[key] = f.apply(this, arguments);\n    };\n}\n')])]),n("ul",[n("li",[e._v("01，利用闭包，将结算结果保存在私有的缓存对象里。")]),n("li",[e._v("02，将实参长度加实参参数作为缓存对象属性。")]),n("li",[e._v("03，如果key属性不存在，就将结果保存在key属性的值。")])]),n("p",[e._v("下面的代码展示了如何使用memorize()：")]),n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// 返回两个整数的最大公约数\n// 使用欧几里德算法:http://en.wikipedia.org/wiki/Euclidean_algorithm\nfunction gcd(a,b) {                     // 这里省略对a和b的类型检查\n    var t;                              // 临时变量用来存储交换数值\n    if (a < b) t=b, b=a, a=t;           // 确保 a >= b\n    while(b != 0) t=b, b = a%b, a=t;    // 这是求最大公约数的欧几里德算法\n    return a;\n}\nvar gcdmemo = memorize(gcd);\ngcdmemo(85, 187) // => 17\n")])]),n("p",[e._v("代码分析By魔芋")]),n("p",[e._v("var gcdmemo = memorize(gcd);")]),n("p",[e._v("f=gcd(a,b);")]),n("p",[e._v("第一次调用时，cache为空对象。 gcdmemo为返回的匿名函数。")]),n("p",[e._v("key为285,187")]),n("p",[e._v("第二次调用时，cache.key已存在，将直接返回计算值。")]),n("hr"),n("p",[e._v("应用一：实现记忆功能的递归函数：")]),n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("var factorial = memorize(function(n) {  \n      return (n <= 1) ? 1 : n * factorial(n-1);\n            });\nfactorial(5)            // => 120.对于4~1的值也有缓存\n")])]),n("p",[e._v("应用二：数组去重：")]),n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("unction unique(arr) {\n  var ret = []\n  var hash = {}\n  for (var i = 0; i < arr.length; i++) {\n    var item = arr[i]\n    var key = typeof(item) + item;\n    if (hash[key] !== 1) {\n      ret.push(item)\n      hash[key] = 1\n    }\n  }\n  return ret;\n}\n")])]),n("p",[e._v("**")])])}],!1,null,null,null);a.default=r.exports}}]);