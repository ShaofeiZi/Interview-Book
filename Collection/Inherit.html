<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Interview Book | Q: 继承</title>
    <meta name="description" content="前端面试题以及前端知识点梳理">
    
    
    <link rel="preload" href="/Interview-Book/assets/css/31.styles.abdfda26.css" as="style"><link rel="preload" href="/Interview-Book/assets/js/app.cc7264ff.js" as="script"><link rel="preload" href="/Interview-Book/assets/js/24.06f1e64c.js" as="script"><link rel="prefetch" href="/Interview-Book/assets/js/15.73cb8c19.js"><link rel="prefetch" href="/Interview-Book/assets/js/0.fa55fd76.js"><link rel="prefetch" href="/Interview-Book/assets/js/1.42f91184.js"><link rel="prefetch" href="/Interview-Book/assets/js/2.855ab1b4.js"><link rel="prefetch" href="/Interview-Book/assets/js/3.e8fce265.js"><link rel="prefetch" href="/Interview-Book/assets/js/4.08e14bbe.js"><link rel="prefetch" href="/Interview-Book/assets/js/5.b4aca0a2.js"><link rel="prefetch" href="/Interview-Book/assets/js/6.48e246c3.js"><link rel="prefetch" href="/Interview-Book/assets/js/7.314c79e2.js"><link rel="prefetch" href="/Interview-Book/assets/js/8.a36a9c77.js"><link rel="prefetch" href="/Interview-Book/assets/js/9.34beea8b.js"><link rel="prefetch" href="/Interview-Book/assets/js/10.9a71a14d.js"><link rel="prefetch" href="/Interview-Book/assets/js/11.a9794c03.js"><link rel="prefetch" href="/Interview-Book/assets/js/12.74576756.js"><link rel="prefetch" href="/Interview-Book/assets/js/13.3a140532.js"><link rel="prefetch" href="/Interview-Book/assets/js/14.860bd71a.js"><link rel="prefetch" href="/Interview-Book/assets/js/16.74524187.js"><link rel="prefetch" href="/Interview-Book/assets/js/17.449fcfbc.js"><link rel="prefetch" href="/Interview-Book/assets/js/18.8d02e026.js"><link rel="prefetch" href="/Interview-Book/assets/js/19.809df8fe.js"><link rel="prefetch" href="/Interview-Book/assets/js/20.6d3cb1ce.js"><link rel="prefetch" href="/Interview-Book/assets/js/21.4b33f39f.js"><link rel="prefetch" href="/Interview-Book/assets/js/22.5b526472.js"><link rel="prefetch" href="/Interview-Book/assets/js/23.116cfae7.js"><link rel="prefetch" href="/Interview-Book/assets/js/25.dc8aafae.js"><link rel="prefetch" href="/Interview-Book/assets/js/26.3bb6309e.js"><link rel="prefetch" href="/Interview-Book/assets/js/27.56fb8f90.js"><link rel="prefetch" href="/Interview-Book/assets/js/28.16962525.js"><link rel="prefetch" href="/Interview-Book/assets/js/29.4cda0dc1.js"><link rel="prefetch" href="/Interview-Book/assets/js/30.53cbda7e.js">
    <link rel="stylesheet" href="/Interview-Book/assets/css/31.styles.abdfda26.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div><a href="/Interview-Book/" class="home-link router-link-active"><!----><span class="site-name">
      Interview Book
    </span></a><div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""><!----></div><nav class="nav-links can-hide"><div class="nav-item"><a href="/Interview-Book/guide/" class="nav-link">Guide</a></div><a href="https://github.com/Liyuk/Interview-Book" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header><div class="sidebar-mask"></div><div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/Interview-Book/guide/" class="nav-link">Guide</a></div><a href="https://github.com/Liyuk/Interview-Book" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav><!----></div><div class="page"><div class="content"><h2 id="q-继承"><a href="#q-继承" aria-hidden="true" class="header-anchor">#</a> Q: 继承</h2><h2 id="a"><a href="#a" aria-hidden="true" class="header-anchor">#</a> A:</h2><p><code>Author: @liyuk @高程（三）</code></p><p>这部分内容其实在2015年就有过详细的编写，但是最近发现当年的代码似乎并没有很明白的阐述原理，重新翻了高程整理一下。<br>
特别强调一下，基本概念！基本概念！基本概念！（怨念）</p><h2 id="es5"><a href="#es5" aria-hidden="true" class="header-anchor">#</a> ES5</h2><h3 id="_1-原型链"><a href="#_1-原型链" aria-hidden="true" class="header-anchor">#</a> 1-原型链</h3><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Super</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">Sub</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token comment">// 继承</span>
Sub<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 生成实例</span>
<span class="token keyword">var</span> sub <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sub</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre><ul><li>所有的类型默认原型为Object</li><li>确定原型和实例的关系</li></ul><pre class="language-js"><code><span class="token comment">// instanceof</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>sub <span class="token keyword">instanceof</span> <span class="token class-name">Sub</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>sub <span class="token keyword">instanceof</span> <span class="token class-name">Super</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>sub <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// isPrototypeOf</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">isPrototypeOf</span><span class="token punctuation">(</span>sub<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><ul><li>定义方法时，要注意区分子类和超类的方法定义，使用字面量创建原型方法会重写原型链</li></ul><pre class="language-js"><code>Sub<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>
    name<span class="token punctuation">:</span> <span class="token string">'liyuk'</span>
<span class="token punctuation">}</span>
</code></pre><h4 id="注意"><a href="#注意" aria-hidden="true" class="header-anchor">#</a> 注意</h4><ul><li>如果原型包含引用类型，所有实例会共享该类型</li><li>创建子类型时，无法在不影响其他实例的情况下，给超类的构造函数传递参数</li></ul><p><strong>实际使用时会较少单独使用原型链</strong></p><h3 id="_2-构造函数"><a href="#_2-构造函数" aria-hidden="true" class="header-anchor">#</a> 2-构造函数</h3><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Super</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">Sub</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 继承</span>
    Super<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// apply 也可以</span>
<span class="token punctuation">}</span>

<span class="token comment">// 生成实例</span>
<span class="token keyword">var</span> sub <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sub</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><ul><li>子类型构造函数可以向超类型构造函数传递参数</li></ul><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Super</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">Sub</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Super<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token string">'liyuk'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><h4 id="注意-2"><a href="#注意-2" aria-hidden="true" class="header-anchor">#</a> 注意</h4><ul><li>函数无法复用</li></ul><h3 id="_3-组合继承"><a href="#_3-组合继承" aria-hidden="true" class="header-anchor">#</a> 3-组合继承</h3><p>即将原型链和构造函数组合在一起。<br>
通过原型链实现对原型属性和方法的继承，通过构造函数来实现对实例属性的继承。</p><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Super</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">Sub</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 构造函数继承</span>
    Super<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 原型链继承</span>
Sub<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 增强对象</span>
Sub<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Sub<span class="token punctuation">;</span>

<span class="token comment">// 生成实例</span>
<span class="token keyword">var</span> sub <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sub</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p><strong>最常用的的继承方法</strong></p><h4 id="注意-3"><a href="#注意-3" aria-hidden="true" class="header-anchor">#</a> 注意</h4><ul><li>会调用两次超类型的构造函数：一次是在创建子类型原型，一次是在子类型构造函数内部</li></ul><h3 id="_4-原型式继承"><a href="#_4-原型式继承" aria-hidden="true" class="header-anchor">#</a> 4-原型式继承</h3><p>借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。</p><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">_object</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 临时构造函数</span>
    <span class="token keyword">function</span> <span class="token constant">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token constant">F</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> o<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> Super <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 继承</span>
<span class="token keyword">var</span> sub <span class="token operator">=</span> <span class="token function">_object</span><span class="token punctuation">(</span>Super<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>es5中的<code>Object.create</code>与<code>_object</code>实现类似，都是用来创建新对象，即副本。</p><h4 id="注意-4"><a href="#注意-4" aria-hidden="true" class="header-anchor">#</a> 注意</h4><ul><li>可以理解为浅拷贝，引用类型依旧会指向同一个地址，与原型链继承一样存在共享值的问题。</li></ul><h3 id="_5-寄生式继承"><a href="#_5-寄生式继承" aria-hidden="true" class="header-anchor">#</a> 5-寄生式继承</h3><p>创建一个仅用于封装继承过程的函数，该函数内部以某种方式增强对象，最后（像）做完所有工作后返回对象。</p><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">_create</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> clone <span class="token operator">=</span> <span class="token function">_object</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// method</span>
    <span class="token keyword">return</span> clone<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>寄生本质上就是进行浅拷贝后生成了新的对象，然后在新的对象上去添加方法，最后返回该新对象。从而实现不对原对象进行修改，并获得了原对象所有方法。</p><h3 id="_6-寄生组合式继承"><a href="#_6-寄生组合式继承" aria-hidden="true" class="header-anchor">#</a> 6-寄生组合式继承</h3><p>组合式继承会有两次调用超类型构造函数的问题。</p><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Super</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">Sub</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 构造函数继承</span>
    Super<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 第二次调用Super</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 原型链继承</span>
Sub<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 第一次调用Super</span>
<span class="token comment">// 增强对象</span>
Sub<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Sub<span class="token punctuation">;</span>

<span class="token comment">// 生成实例</span>
<span class="token keyword">var</span> sub <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sub</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>第二次在Sub构造函数内部调用Super时，生成了新的属性，从而屏蔽了原型中（超类型）的同名属性。</p><p>寄生组合式继承，<strong>即通过构造函数来继承属性，通过原型链的混成形式来集成方法。</strong><br>
基本思路是<strong>不必为了指定子类型的原型而调用超类型的构造函数</strong></p><pre class="language-js"><code><span class="token comment">// 寄生</span>
<span class="token keyword">function</span> <span class="token function">inherit</span><span class="token punctuation">(</span>sub<span class="token punctuation">,</span> <span class="token keyword">super</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 高程三中的写法是 var prototype = Object(super.prototype);</span>
    <span class="token comment">// 这样写可能有些问题，会污染超类型的原型，保持疑惑</span>
    <span class="token comment">// 所以有可能是用Object.create，或者上文提到的原型式继承_obejct，或者寄生式继承的_create</span>
    <span class="token comment">// Comment: @bramble</span>
    <span class="token keyword">var</span> prototype <span class="token operator">=</span> <span class="token function">Object</span><span class="token punctuation">(</span><span class="token keyword">super</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 创建对象，创建超类型原型副本</span>
    prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> sub<span class="token punctuation">;</span>                     <span class="token comment">// 增强对象，弥补因重写原型而失去的默认constructor</span>
    sub<span class="token punctuation">.</span>prototype <span class="token operator">=</span> prototype<span class="token punctuation">;</span>                       <span class="token comment">// 指定对象</span>
<span class="token punctuation">}</span>
</code></pre><p>修改后的寄生组合模式为</p><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Super</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">Sub</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 使用构造函数来继承属性</span>
    Super<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 使用寄生来混入原型链</span>
<span class="token function">_inherit</span><span class="token punctuation">(</span>Sub<span class="token punctuation">,</span> Super<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 生成实例</span>
<span class="token keyword">var</span> sub <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sub</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre><p><strong>寄生组合式继承是最<code>引用</code>类型最理想的继承范式</strong></p><h3 id="_7-object-create-mdn-兼容性：ie9"><a href="#_7-object-create-mdn-兼容性：ie9" aria-hidden="true" class="header-anchor">#</a> 7-Object.create <code>@MDN</code><code>兼容性：IE9+</code></h3><pre class="language-js"><code><span class="token comment">// Super - 父类(superclass)</span>
<span class="token keyword">function</span> <span class="token function">Super</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 父类的方法</span>
Super<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">move</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">+=</span> x<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">+=</span> y<span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">'Super moved.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// Sub - 子类(subclass)</span>
<span class="token keyword">function</span> <span class="token function">Sub</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Super<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// call super constructor.</span>
<span class="token punctuation">}</span>

<span class="token comment">// 子类续承父类</span>
Sub<span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>Super<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>
Sub<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Sub<span class="token punctuation">;</span>

<span class="token comment">// 因为使用“.prototype =...”后,constructor会改变为“=...”的那个</span>
<span class="token comment">// constructor，所以要重新指定.constructor 为自身。</span>
</code></pre><h4 id="polyfill"><a href="#polyfill" aria-hidden="true" class="header-anchor">#</a> polyfill</h4><p>尽管在 ES5 中 Object.create支持设置为[[Prototype]]为null，但因为那些ECMAScript5以前版本限制，此 polyfill 无法支持该特性。</p><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> Object<span class="token punctuation">.</span>create <span class="token operator">!==</span> <span class="token string">&quot;function&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Object<span class="token punctuation">.</span><span class="token function-variable function">create</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>proto<span class="token punctuation">,</span> propertiesObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> proto <span class="token operator">!==</span> <span class="token string">'object'</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> proto <span class="token operator">!==</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">'Object prototype may only be an Object: '</span> <span class="token operator">+</span> proto<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>proto <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">&quot;This browser's implementation of Object.create is a shim and doesn't support 'null' as the first argument.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> propertiesObject <span class="token operator">!=</span> <span class="token string">'undefined'</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">&quot;This browser's implementation of Object.create is a shim and doesn't support a second argument.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">function</span> <span class="token constant">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
        <span class="token constant">F</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> proto<span class="token punctuation">;</span>

        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><h2 id="es6"><a href="#es6" aria-hidden="true" class="header-anchor">#</a> ES6</h2><h3 id="class-extends-ruanyifeng"><a href="#class-extends-ruanyifeng" aria-hidden="true" class="header-anchor">#</a> Class extends <code>@ruanyifeng</code></h3><p>es6的class其实就是个语法糖，babel转出来的依旧是寄生组合式继承。
具体的使用没有太多的可以说的，需要注意super即可以当函数，也可以实例。这部分不做细说，因为很复杂，有兴趣参考<a href="http://es6.ruanyifeng.com/#docs/class-extends#super-%E5%85%B3%E9%94%AE%E5%AD%97" target="_blank" rel="noopener noreferrer">es6 Class的继承</a>。<br>
需要注意的是，<strong>ES5的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。ES6 的继承机制完全不同，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。</strong></p><h3 id="object-setprototypeof"><a href="#object-setprototypeof" aria-hidden="true" class="header-anchor">#</a> Object.setPrototypeOf</h3><p>将一个指定的对象的原型设置为另一个对象或者null</p><pre class="language-js"><code><span class="token comment">// 语法</span>
Object<span class="token punctuation">.</span><span class="token function">setPrototypeOf</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> prototype<span class="token punctuation">)</span>

<span class="token comment">// 实现原理</span>
Object<span class="token punctuation">.</span>setPrototypeOf <span class="token operator">=</span> Object<span class="token punctuation">.</span>setPrototypeOf <span class="token operator">||</span> <span class="token keyword">function</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> proto<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    obj<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> proto<span class="token punctuation">;</span>
    <span class="token keyword">return</span> obj<span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
</code></pre><h2 id="其他"><a href="#其他" aria-hidden="true" class="header-anchor">#</a> 其他</h2><h3 id="继承在js当中的使用"><a href="#继承在js当中的使用" aria-hidden="true" class="header-anchor">#</a> 继承在js当中的使用</h3><ul><li>高阶函数+工厂模式，可以实现继承的效果，原理偏向于构造函数实现继承</li><li>react、vue等基础库对于各种基础类型的继承</li><li>复杂数据结构，诸如树、图等结构的复用和扩展</li><li>canvas，基本图像类 派生出 线 圆 等各个需要的东西<code>@vamcc</code></li></ul><h3 id="多继承"><a href="#多继承" aria-hidden="true" class="header-anchor">#</a> 多继承</h3><p>多继承是个伪命题，会导致菱形继承。</p><pre class="language-js"><code><span class="token constant">B</span> <span class="token keyword">extends</span> <span class="token class-name">A</span>
<span class="token constant">C</span> <span class="token keyword">extends</span> <span class="token class-name">A</span>

<span class="token constant">D</span> <span class="token keyword">extends</span> <span class="token class-name">B</span><span class="token punctuation">,</span> <span class="token constant">C</span>

<span class="token comment">// 原型链合并</span>
<span class="token keyword">var</span> sub <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sub</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

Sub<span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> Sub<span class="token punctuation">.</span>prototype<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Super2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 构造函数</span>
<span class="token keyword">function</span> <span class="token function">Sub</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Super1<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Super2<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>有兴趣去看看C++的菱形继承和虚继承，没兴趣不用在意。</p><h2 id="roast"><a href="#roast" aria-hidden="true" class="header-anchor">#</a> Roast</h2><p>基本概念！基本概念！基本概念！<br>
一脸懵逼，生无可恋。</p></div><div class="content edit-link"><a href="https://github.com/Liyuk/Interview-Book/edit/vuepress/docs/Collection/Inherit.md" target="_blank" rel="noopener noreferrer">帮助我们改善此页面！</a><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div><!----></div></div></div>
    <script src="/Interview-Book/assets/js/24.06f1e64c.js" defer></script><script src="/Interview-Book/assets/js/app.cc7264ff.js" defer></script>
  </body>
</html>
